#!/bin/bash

# Review Gate V2 - One-Click Installation Script
# Author: Lakshman Turlapati
# This script installs Review Gate V2 globally for Cursor IDE

set -e  # Exit on any error

# Enhanced colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
WHITE='\033[1;37m'
CYAN='\033[0;36m'
GRAY='\033[0;37m'
NC='\033[0m' # No Color

# Logging functions
log_error() { echo -e "${RED}ERROR: $1${NC}"; }
log_success() { echo -e "${GREEN}SUCCESS: $1${NC}"; }
log_info() { echo -e "${YELLOW}INFO: $1${NC}"; }
log_progress() { echo -e "${CYAN}PROGRESS: $1${NC}"; }
log_warning() { echo -e "${YELLOW}WARNING: $1${NC}"; }
log_step() { echo -e "${WHITE}$1${NC}"; }

# Get script directory
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"

# Function to switch apt sources when connection fails
switch_apt_sources() {
    local sources_file="/etc/apt/sources.list"
    local backup_file="/etc/apt/sources.list.backup.$(date +%Y%m%d_%H%M%S)"
    
    log_warning "Default apt sources may be unreachable, attempting to switch to mirror sources..."
    
    # Backup original sources.list
    if [[ -f "$sources_file" ]]; then
        sudo cp "$sources_file" "$backup_file"
        log_info "Original sources backed up to: $backup_file"
    fi
    
    # Detect Ubuntu/Debian version
    local version_codename=""
    if [[ -f /etc/os-release ]]; then
        version_codename=$(grep VERSION_CODENAME /etc/os-release | cut -d= -f2 | tr -d '"')
    fi
    
    if [[ -z "$version_codename" ]]; then
        # Fallback detection
        version_codename=$(lsb_release -sc 2>/dev/null || echo "focal")
    fi
    
    log_info "Detected version codename: $version_codename"
    
    # Try different mirror sources
    local mirrors=(
        "https://mirrors.tuna.tsinghua.edu.cn/ubuntu/"  # 清华大学镜像
        "https://mirrors.aliyun.com/ubuntu/"            # 阿里云镜像
        "https://mirrors.huaweicloud.com/ubuntu/"       # 华为云镜像
        "https://mirrors.163.com/ubuntu/"               # 网易镜像
    )
    
    for mirror in "${mirrors[@]}"; do
        log_progress "Trying mirror: $mirror"
        
        # Create new sources.list
        sudo tee "$sources_file" > /dev/null <<EOF
# Mirror sources - automatically generated by Review Gate installer
deb $mirror $version_codename main restricted universe multiverse
deb $mirror $version_codename-updates main restricted universe multiverse
deb $mirror $version_codename-backports main restricted universe multiverse
deb $mirror $version_codename-security main restricted universe multiverse
EOF
        
        # Test the mirror
        if timeout 30s sudo apt-get update >/dev/null 2>&1; then
            log_success "Successfully switched to mirror: $mirror"
            return 0
        else
            log_warning "Mirror failed: $mirror"
        fi
    done
    
    # If all mirrors fail, restore original
    if [[ -f "$backup_file" ]]; then
        log_warning "All mirrors failed, restoring original sources"
        sudo cp "$backup_file" "$sources_file"
    fi
    
    return 1
}

# Enhanced apt-get function with source switching
safe_apt_install() {
    local packages="$@"
    local max_retries=2
    local retry_count=0
    
    while [[ $retry_count -lt $max_retries ]]; do
        log_progress "Updating package cache (attempt $((retry_count + 1))/$max_retries)..."
        
        if timeout 60s sudo apt-get update; then
            log_progress "Installing packages: $packages"
            if sudo apt-get install -y $packages; then
                log_success "Successfully installed: $packages"
                return 0
            else
                log_warning "Package installation failed"
            fi
        else
            log_warning "Package cache update failed"
        fi
        
        # Try switching sources on failure
        if [[ $retry_count -eq 0 ]]; then
            if switch_apt_sources; then
                log_info "Retrying with new mirror sources..."
            else
                log_error "Failed to switch to alternative sources"
                return 1
            fi
        fi
        
        retry_count=$((retry_count + 1))
    done
    
    log_error "Failed to install packages after $max_retries attempts: $packages"
    return 1
}

# Universal package installation function with package manager fallback
install_package_universal() {
    local packages_apt="$1"
    local packages_yum="$2"
    local packages_dnf="$3"
    local packages_pacman="$4"
    local packages_zypper="$5"
    local description="$6"
    
    log_progress "Installing $description..."
    
    # Try package managers in order of preference
    local managers=("apt-get" "yum" "dnf" "zypper" "pacman")
    
    for manager in "${managers[@]}"; do
        if command -v "$manager" &> /dev/null; then
            log_progress "Attempting installation via $manager..."
            
            case "$manager" in
                "apt-get")
                    if safe_apt_install $packages_apt; then
                        log_success "$description installed successfully via apt-get"
                        return 0
                    else
                        log_warning "apt-get installation failed, trying next package manager..."
                    fi
                    ;;
                "yum")
                    # Enable EPEL for better package availability
                    if sudo yum install -y epel-release 2>/dev/null; then
                        log_info "EPEL repository enabled"
                    fi
                    if sudo yum install -y $packages_yum; then
                        log_success "$description installed successfully via yum"
                        return 0
                    else
                        log_warning "yum installation failed, trying next package manager..."
                    fi
                    ;;
                "dnf")
                    if sudo dnf install -y $packages_dnf; then
                        log_success "$description installed successfully via dnf"
                        return 0
                    else
                        log_warning "dnf installation failed, trying next package manager..."
                    fi
                    ;;
                "zypper")
                    if sudo zypper install -y $packages_zypper; then
                        log_success "$description installed successfully via zypper"
                        return 0
                    else
                        log_warning "zypper installation failed, trying next package manager..."
                    fi
                    ;;
                "pacman")
                    if sudo pacman -S --noconfirm $packages_pacman; then
                        log_success "$description installed successfully via pacman"
                        return 0
                    else
                        log_warning "pacman installation failed, trying next package manager..."
                    fi
                    ;;
            esac
        fi
    done
    
    log_error "Failed to install $description with any available package manager"
    return 1
}

echo -e "${BLUE}Review Gate V2 - One-Click Installation${NC}"
echo -e "${BLUE}=========================================${NC}"
echo ""

# Detect operating system
if [[ "$OSTYPE" == "linux-gnu"* ]]; then
    OS="linux"
    PACKAGE_MANAGER="apt-get"
    INSTALL_CMD="sudo $PACKAGE_MANAGER install -y"
elif [[ "$OSTYPE" == "darwin"* ]]; then
    OS="macos"
    PACKAGE_MANAGER="brew"
    INSTALL_CMD="$PACKAGE_MANAGER install"
else
    log_error "Unsupported operating system: $OSTYPE"
    log_info "This script is designed for Linux and macOS"
    exit 1
fi

log_success "Detected OS: $OS"

# Only install Homebrew on macOS
if [[ "$OS" == "macos" ]]; then
    if ! command -v brew &> /dev/null; then
        log_progress "Installing Homebrew (macOS package manager)..."
        /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
    else
        log_success "Homebrew already installed"
    fi
fi

# Install SoX for speech-to-text
log_progress "Installing SoX for speech-to-text..."
if ! command -v sox &> /dev/null; then
    if [[ "$OS" == "linux" ]]; then
        # Use universal package installation with automatic fallback
        if ! install_package_universal "sox libsox-fmt-all" "sox" "sox" "sox" "sox" "SoX audio library"; then
            log_warning "Standard SoX installation failed, trying with additional repositories..."
            
            # Try enabling additional repositories and retry
            log_progress "Enabling additional repositories..."
            
            # For apt systems, try universe repository
            if command -v apt-get &> /dev/null; then
                if safe_apt_install software-properties-common; then
                    sudo add-apt-repository universe -y 2>/dev/null || true
                    safe_apt_install sox libsox-fmt-all || true
                fi
            fi
            
            # Final fallback - manual installation instructions
            if ! command -v sox &> /dev/null; then
                log_warning "SoX installation failed with all package managers"
                log_info "Manual installation options:"
                log_step "   Rerun script (auto tries multiple package managers and mirror sources)"
                log_step "   Ubuntu/Debian: sudo apt-get install sox libsox-fmt-all"
                log_step "   RHEL/CentOS/OpenCloud OS: sudo yum install epel-release && sudo yum install sox"
                log_step "   Fedora: sudo dnf install sox"
                log_step "   Arch: sudo pacman -S sox"
                log_step "   From source: wget sox source, ./configure, make, make install"
            fi
        fi
    else
        $INSTALL_CMD sox
    fi
else
    log_success "SoX already installed"
fi

# Validate SoX installation and microphone access
log_progress "Validating SoX and microphone setup..."
if command -v sox &> /dev/null; then
    SOX_VERSION=$(sox --version 2>&1 | head -n1)
    log_success "SoX found: $SOX_VERSION"
    
    # Test microphone access (quick test)
    log_progress "Testing microphone access..."
    if timeout 3s sox -d -r 16000 -c 1 /tmp/sox_test_$$.wav trim 0 0.1 2>/dev/null; then
        rm -f /tmp/sox_test_$$.wav
        log_success "Microphone access test successful"
    else
        rm -f /tmp/sox_test_$$.wav
        log_warning "Microphone test failed - speech features may not work"
        log_info "Common fixes:"
        log_step "   - Grant microphone permissions to Terminal/iTerm"
        log_step "   - Check System Preferences > Security & Privacy > Microphone"
        log_step "   - Make sure no other apps are using the microphone"
    fi
else
    log_error "SoX installation failed"
    log_info "Speech-to-text features will be disabled"
    if [[ "$OS" == "macos" ]]; then
        log_info "Try: brew install sox"
    else
        log_info "Try: Rerun script (auto tries apt-get, yum, dnf with mirror switching)"
    fi
fi

# Check if Python 3 is available
if ! command -v python3 &> /dev/null; then
    log_error "Python 3 is required but not installed"
    log_info "Please install Python 3 and run this script again"
    exit 1
else
    log_success "Python 3 found: $(python3 --version)"
fi

# Create global Cursor extensions directory
CURSOR_EXTENSIONS_DIR="$HOME/cursor-extensions"
REVIEW_GATE_DIR="$CURSOR_EXTENSIONS_DIR/review-gate-v2"

log_progress "Creating global installation directory..."
mkdir -p "$REVIEW_GATE_DIR"

# Copy MCP server files
log_progress "Copying MCP server files..."
cp "$SCRIPT_DIR/review_gate_v2_mcp.py" "$REVIEW_GATE_DIR/"
cp "$SCRIPT_DIR/requirements_simple.txt" "$REVIEW_GATE_DIR/"

# Create Python virtual environment
log_progress "Creating Python virtual environment..."
cd "$REVIEW_GATE_DIR"

# Install Python virtual environment support on Linux if needed
if [[ "$OS" == "linux" ]]; then
    log_progress "Installing Python virtual environment support..."
    
    # Check if python3-venv/virtualenv is already installed
    venv_installed=false
    
    # Check for different venv installations
    if dpkg -s python3-venv >/dev/null 2>&1 || rpm -q python3-virtualenv >/dev/null 2>&1 || python3 -m venv --help >/dev/null 2>&1; then
        venv_installed=true
        log_success "Python virtual environment support already available"
    fi
    
    # Install if not already available
    if [[ "$venv_installed" != "true" ]]; then
        # Use universal installer with fallback across package managers
        if ! install_package_universal "python3-venv" "python3-virtualenv python3-pip" "python3-virtualenv python3-pip" "python-virtualenv python-pip" "python-virtualenv python-pip" "Python virtual environment support"; then
            log_warning "Failed to install python virtual environment packages"
            log_info "Attempting to proceed anyway - Python may have built-in venv support"
        fi
    fi
fi

python3 -m venv venv

# Activate virtual environment and install dependencies
log_progress "Installing Python dependencies..."
source venv/bin/activate
pip install --upgrade pip

# Install dependencies with better error handling
log_progress "Installing core dependencies (mcp, pillow)..."
pip install mcp>=1.9.2 Pillow>=10.0.0 asyncio typing-extensions>=4.14.0

# Install faster-whisper with platform-specific handling
log_progress "Installing faster-whisper for speech-to-text..."
if pip install faster-whisper>=1.0.0; then
    log_success "faster-whisper installed successfully"
else
    log_warning "faster-whisper installation failed - trying alternative approach"
    # Try installing without CUDA dependencies for CPU-only
    if pip install faster-whisper>=1.0.0 --no-deps; then
        pip install torch torchaudio --index-url https://download.pytorch.org/whl/cpu
        log_success "faster-whisper installed with CPU-only dependencies"
    else
        log_error "faster-whisper installation failed"
        log_info "Speech-to-text will be disabled"
        log_info "You can manually install later: pip install faster-whisper"
    fi
fi

deactivate

log_success "Python environment created and dependencies installed"

# Create MCP configuration
CURSOR_MCP_FILE="$HOME/.cursor/mcp.json"
log_progress "Configuring MCP servers..."
mkdir -p "$HOME/.cursor"

# Backup existing MCP configuration if it exists
if [[ -f "$CURSOR_MCP_FILE" ]]; then
    BACKUP_FILE="$CURSOR_MCP_FILE.backup.$(date +%Y%m%d_%H%M%S)"
    log_info "Backing up existing MCP configuration to: $BACKUP_FILE"
    cp "$CURSOR_MCP_FILE" "$BACKUP_FILE"
    
    # Check if the existing config is valid JSON (simplified)
    if ! python3 -c "import json; json.load(open('$CURSOR_MCP_FILE'))" >/dev/null 2>&1; then
        log_warning "Existing MCP config has invalid JSON format"
        log_info "Creating new configuration file"
        HAS_EXISTING_SERVERS=false
    else
        log_success "Found existing MCP configuration, will merge servers"
        HAS_EXISTING_SERVERS=true
    fi
else
    log_info "Creating new MCP configuration file"
    HAS_EXISTING_SERVERS=false
fi

# Create simplified MCP configuration
log_progress "Configuring MCP servers..."

# Create the new configuration using a simple Python script
python3 -c "
import json
import os

config_file = '$CURSOR_MCP_FILE'
review_gate_dir = '$REVIEW_GATE_DIR'
has_existing = $([[ "$HAS_EXISTING_SERVERS" == "true" ]] && echo "True" || echo "False")

# Read existing config if available
existing_servers = {}
if has_existing and os.path.exists(config_file):
    try:
        with open(config_file, 'r') as f:
            existing_config = json.load(f)
            existing_servers = existing_config.get('mcpServers', {})
            # Remove review-gate-v2 if it exists (we'll add the new one)
            existing_servers.pop('review-gate-v2', None)
    except:
        existing_servers = {}

# Add Review Gate V2 configuration
existing_servers['review-gate-v2'] = {
    'command': os.path.join(review_gate_dir, 'venv/bin/python'),
    'args': [os.path.join(review_gate_dir, 'review_gate_v2_mcp.py')],
    'env': {
        'PYTHONPATH': review_gate_dir,
        'PYTHONUNBUFFERED': '1',
        'REVIEW_GATE_MODE': 'cursor_integration'
    }
}

# Write the configuration
config = {'mcpServers': existing_servers}
os.makedirs(os.path.dirname(config_file), exist_ok=True)
with open(config_file, 'w') as f:
    json.dump(config, f, indent=2)
"

if [[ $? -eq 0 ]]; then
    log_success "MCP configuration updated successfully"
else
    log_error "Failed to update MCP configuration"
    exit 1
fi

# Validate the generated configuration
if python3 -c "import json; json.load(open('$CURSOR_MCP_FILE'))" >/dev/null 2>&1; then
    log_success "MCP configuration file created at: $CURSOR_MCP_FILE"
    
    # Count configured servers (simplified)
    SERVER_COUNT=$(python3 -c "import json; print(len(json.load(open('$CURSOR_MCP_FILE')).get('mcpServers', {})))")
    log_step "Total MCP servers configured: $SERVER_COUNT"
    log_step "  - review-gate-v2 (Review Gate V2)"
else
    log_error "Generated MCP configuration is invalid"
    if [[ -f "$BACKUP_FILE" ]]; then
        log_progress "Restoring from backup..."
        cp "$BACKUP_FILE" "$CURSOR_MCP_FILE"
        log_success "Backup restored"
    else
        log_error "No backup available, installation failed"
        exit 1
    fi
fi

# Test MCP server
log_progress "Testing MCP server..."
cd "$REVIEW_GATE_DIR"
source venv/bin/activate
TEMP_DIR=$(python3 -c 'import tempfile; print(tempfile.gettempdir())')
timeout 5s python review_gate_v2_mcp.py > "$TEMP_DIR/mcp_test.log" 2>&1 || true
deactivate

if grep -q "Review Gate 2.0 server initialized" "$TEMP_DIR/mcp_test.log"; then
    log_success "MCP server test successful"
else
    log_warning "MCP server test inconclusive (may be normal)"
fi
rm -f "$TEMP_DIR/mcp_test.log"

# Install Cursor extension
EXTENSION_FILE="$SCRIPT_DIR/cursor-extension/review-gate-v2-2.7.3.vsix"
if [[ -f "$EXTENSION_FILE" ]]; then
    log_progress "Installing Cursor extension..."
    
    # Copy extension to installation directory
    cp "$EXTENSION_FILE" "$REVIEW_GATE_DIR/"
    
    # Try automated installation first
    EXTENSION_INSTALLED=false
    if command -v cursor &> /dev/null; then
        log_progress "Attempting automated extension installation..."
        if cursor --install-extension "$EXTENSION_FILE" >/dev/null 2>&1; then
            log_success "Extension installed automatically via command line"
            EXTENSION_INSTALLED=true
        else
            log_warning "Automated installation failed, falling back to manual method"
        fi
    fi
    
    # If automated installation failed, provide manual instructions
    if [[ "$EXTENSION_INSTALLED" == false ]]; then
        echo -e "${BLUE}MANUAL EXTENSION INSTALLATION REQUIRED:${NC}"
        log_info "Please complete the extension installation manually:"
        log_step "1. Open Cursor IDE"
        log_step "2. Press Cmd+Shift+P (or Ctrl+Shift+P on Linux)"
        log_step "3. Type 'Extensions: Install from VSIX'"
        log_step "4. Select: $REVIEW_GATE_DIR/review-gate-v2-2.7.3.vsix"
        log_step "5. Restart Cursor when prompted"
        echo ""
        
        # Try to open Cursor if available
        if command -v cursor &> /dev/null; then
            log_progress "Opening Cursor IDE..."
            cursor . &
        elif [[ -d "/Applications/Cursor.app" ]]; then
            log_progress "Opening Cursor IDE..."
            open -a "Cursor" . &
        else
            log_info "Please open Cursor IDE manually"
        fi
    fi
else
    log_error "Extension file not found: $EXTENSION_FILE"
    log_info "Please ensure the extension is built in cursor-extension/ directory"
    log_info "Or install manually from the Cursor Extensions marketplace"
fi

# Install global rule (optional) - Cross-platform directory detection
if [[ "$OS" == "macos" ]]; then
    CURSOR_RULES_DIR="$HOME/Library/Application Support/Cursor/User/rules"
elif [[ "$OS" == "linux" ]]; then
    CURSOR_RULES_DIR="$HOME/.config/Cursor/User/rules"
fi

if [[ -f "$SCRIPT_DIR/ReviewGate.mdc" ]] && [[ -n "$CURSOR_RULES_DIR" ]]; then
    log_progress "Installing global rule..."
    mkdir -p "$CURSOR_RULES_DIR"
    cp "$SCRIPT_DIR/ReviewGate.mdc" "$CURSOR_RULES_DIR/"
    log_success "Global rule installed to: $CURSOR_RULES_DIR"
elif [[ -f "$SCRIPT_DIR/ReviewGate.mdc" ]]; then
    log_warning "Could not determine Cursor rules directory for this platform"
    log_info "Global rule available at: $SCRIPT_DIR/ReviewGate.mdc"
fi

# Clean up any existing temp files
log_progress "Cleaning up temporary files..."
TEMP_DIR=$(python3 -c 'import tempfile; print(tempfile.gettempdir())')
rm -f "$TEMP_DIR"/review_gate_* "$TEMP_DIR"/mcp_response* 2>/dev/null || true

echo ""
log_success "Review Gate V2 Installation Complete!"
echo -e "${GREEN}=======================================${NC}"
echo ""
echo -e "${BLUE}Installation Summary:${NC}"
log_step "   - MCP Server: $REVIEW_GATE_DIR"
log_step "   - MCP Config: $CURSOR_MCP_FILE"
log_step "   - Extension: $REVIEW_GATE_DIR/review-gate-v2-2.7.3.vsix"
log_step "   - Global Rule: $CURSOR_RULES_DIR/ReviewGate.mdc"
echo ""
echo -e "${BLUE}Testing Your Installation:${NC}"
log_step "1. Restart Cursor completely"
log_step "2. Press Cmd+Shift+R to test manual trigger"
log_step "3. Or ask Cursor Agent: 'Use the review_gate_chat tool'"
echo ""
echo -e "${BLUE}Speech-to-Text Features:${NC}"
log_step "   - Click microphone icon in popup"
log_step "   - Speak clearly for 2-3 seconds"
log_step "   - Click stop to transcribe"
echo ""
echo -e "${BLUE}Image Upload Features:${NC}"
log_step "   - Click camera icon in popup"
log_step "   - Select images (PNG, JPG, etc.)"
log_step "   - Images are included in response"
echo ""
echo -e "${BLUE}Troubleshooting:${NC}"
log_step "   - Logs: tail -f $(python3 -c 'import tempfile; print(tempfile.gettempdir())')/review_gate_v2.log"
log_step "   - Test SoX: sox --version"
log_step "   - Browser Console: F12 in Cursor"
echo ""
log_success "Enjoy your voice-activated Review Gate!"

# Final verification
log_progress "Final verification..."
if [[ -f "$REVIEW_GATE_DIR/review_gate_v2_mcp.py" ]] && \
   [[ -f "$CURSOR_MCP_FILE" ]] && \
   [[ -d "$REVIEW_GATE_DIR/venv" ]]; then
    log_success "All components installed successfully"
    exit 0
else
    log_error "Some components may not have installed correctly"
    log_info "Please check the installation manually"
    exit 1
fi